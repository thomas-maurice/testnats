package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"connectrpc.com/connect"
	"github.com/nats-io/nats.go"
	"github.com/thomas-maurice/natsgrpc/natsrpc"

	luav1 "github.com/thomas-maurice/testnats/gen/lua/v1"
	"github.com/thomas-maurice/testnats/gen/lua/v1/luav1connect"
)

func main() {
	natsURL := os.Getenv("NATS_URL")
	if natsURL == "" {
		natsURL = nats.DefaultURL
	}
	subject := os.Getenv("NATS_SUBJECT")
	if subject == "" {
		subject = "rpc"
	}

	log.Printf("connecting to NATS at %s", natsURL)

	nc, err := nats.Connect(natsURL)
	if err != nil {
		log.Fatalf("failed to connect to NATS: %v", err)
	}
	defer nc.Close()

	httpClient := natsrpc.NewHTTPClient(nc, subject)
	client := luav1connect.NewLuaServiceClient(httpClient, "http://nats")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	scripts := []struct {
		name      string
		script    string
		variables map[string]string
	}{
		{
			name: "Hello World",
			script: `
print("Hello from Lua over NATS!")
"hello world"
`,
		},
		{
			name: "Simple math",
			script: `
-- The last expression is automatically the result
2 + 2
`,
		},
		{
			name: "JSON roundtrip",
			script: `
local json = require("json")

local data = {
    name = name,
    language = "Lua",
    transport = "NATS",
    framework = "ConnectRPC",
}

local encoded = json.stringify(data)
print("JSON: " .. encoded)

local decoded = json.parse(encoded)
print("Name from JSON: " .. decoded.name)

encoded
`,
			variables: map[string]string{
				"name": "glua-nats-demo",
			},
		},
		{
			name: "Hash computation",
			script: `
local hash = require("hash")
local base64 = require("base64")

local message = secret_message
print("Message: " .. message)

print("SHA256: " .. hash.sha256(message))
print("Base64: " .. base64.encode(message))

hash.sha256(message)
`,
			variables: map[string]string{
				"secret_message": "NATS is awesome!",
			},
		},
		{
			name: "Template rendering",
			script: `
local template = require("template")

local tmpl = "Hello {{.Name}}, welcome to {{.Place}}!"
local rendered = template.render(tmpl, {
    Name = greeting_name,
    Place = "the NATS-powered Lua executor",
})

print(rendered)
rendered
`,
			variables: map[string]string{
				"greeting_name": "World",
			},
		},
		{
			name: "YAML generation",
			script: `
local yaml = require("yaml")

local config = {
    apiVersion = "v1",
    kind = "ConfigMap",
    metadata = {
        name = "generated-by-lua",
        namespace = "default",
        labels = {
            app = app_name,
            generator = "glua-nats",
        },
    },
    data = {
        message = "This config was generated by a Lua script running over NATS!",
    },
}

local output = yaml.stringify(config)
print(output)
output
`,
			variables: map[string]string{
				"app_name": "testnats",
			},
		},
		{
			name: "Error handling",
			script: `
-- This will cause an error
local x = nil
x.foo()
`,
		},
	}

	for _, s := range scripts {
		fmt.Printf("\n%s\n", strings.Repeat("=", 60))
		fmt.Printf("Script: %s\n", s.name)
		fmt.Printf("%s\n", strings.Repeat("=", 60))

		resp, err := client.Execute(ctx, connect.NewRequest(&luav1.ExecuteRequest{
			Script:    s.script,
			Variables: s.variables,
		}))
		if err != nil {
			log.Printf("RPC error: %v", err)
			continue
		}

		if len(resp.Msg.Logs) > 0 {
			fmt.Println("Output:")
			for _, line := range resp.Msg.Logs {
				fmt.Printf("  %s\n", line)
			}
		}

		if resp.Msg.Error != "" {
			fmt.Printf("Lua Error: %s\n", resp.Msg.Error)
		} else if resp.Msg.Result != "" {
			fmt.Printf("Result: %s\n", resp.Msg.Result)
		}
	}

	fmt.Printf("\n%s\n", strings.Repeat("=", 60))
	fmt.Println("All scripts executed!")

	// Interactive mode: read scripts from files passed as arguments
	for _, arg := range os.Args[1:] {
		data, err := os.ReadFile(arg)
		if err != nil {
			log.Printf("failed to read %s: %v", arg, err)
			continue
		}

		fmt.Printf("\n%s\n", strings.Repeat("=", 60))
		fmt.Printf("Script file: %s\n", arg)
		fmt.Printf("%s\n", strings.Repeat("=", 60))

		resp, err := client.Execute(ctx, connect.NewRequest(&luav1.ExecuteRequest{
			Script: string(data),
		}))
		if err != nil {
			log.Printf("RPC error: %v", err)
			continue
		}

		if len(resp.Msg.Logs) > 0 {
			fmt.Println("Output:")
			for _, line := range resp.Msg.Logs {
				fmt.Printf("  %s\n", line)
			}
		}

		if resp.Msg.Error != "" {
			fmt.Printf("Lua Error: %s\n", resp.Msg.Error)
		} else if resp.Msg.Result != "" {
			fmt.Printf("Result: %s\n", resp.Msg.Result)
		}
	}
}
